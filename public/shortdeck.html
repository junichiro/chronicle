<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Short Deck (6+) Viewer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { 
    background: #1a472a; 
    color: #fff; 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px;
  }
  h1 { font-size: 1.1em; margin-bottom: 2px; }
  .subtitle { color: #aaa; font-size: 0.7em; margin-bottom: 8px; }
  
  .board-area {
    background: rgba(0,0,0,0.3);
    border-radius: 12px;
    padding: 8px 16px;
    margin-bottom: 8px;
    text-align: center;
  }
  .board-label { font-size: 0.65em; color: #8fb; margin-bottom: 4px; }
  .board-cards { display: flex; gap: 4px; justify-content: center; min-height: 52px; align-items: center; }
  
  .players-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
    max-width: 360px;
    width: 100%;
    margin-bottom: 8px;
  }
  
  .player {
    background: rgba(0,0,0,0.25);
    border-radius: 8px;
    padding: 4px;
    text-align: center;
    transition: all 0.3s;
  }
  .player-name { font-size: 0.6em; color: #aaa; margin-bottom: 2px; }
  .player-hand { display: flex; gap: 2px; justify-content: center; }
  .player-info { font-size: 0.5em; color: #aaa; margin-top: 2px; min-height: 0.9em; line-height: 1.3; }
  .player-equity { font-size: 0.55em; color: #4fc3f7; margin-top: 1px; min-height: 0.8em; }
  .player.winner { 
    background: rgba(255,200,0,0.2); 
    border: 2px solid #ffd54f;
    box-shadow: 0 0 8px rgba(255,200,0,0.3);
  }
  .player.winner .player-name { color: #ffd54f; font-weight: bold; }
  .player.winner .player-info { color: #ffd54f; font-weight: bold; }
  .player.folded { opacity: 0.3; }
  .player.folded .player-name::after { content: ' FOLD'; color: #f44; font-size: 0.9em; }
  
  .card {
    width: 30px;
    height: 44px;
    background: #fff;
    border-radius: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.85em;
    line-height: 1;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    user-select: none;
  }
  .card.red { color: #d32f2f; }
  .card.black { color: #222; }
  .card .rank { font-size: 0.85em; }
  .card .suit { font-size: 0.7em; margin-top: -1px; }
  
  .board-card {
    width: 38px;
    height: 54px;
    font-size: 1em;
  }
  .board-card .rank { font-size: 0.95em; }
  .board-card .suit { font-size: 0.8em; }
  
  .placeholder {
    width: 38px;
    height: 54px;
    border: 2px dashed rgba(255,255,255,0.15);
    border-radius: 4px;
  }
  
  .controls {
    display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; margin-bottom: 6px;
  }
  button {
    background: #2e7d32;
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 0.85em;
    cursor: pointer;
    transition: background 0.2s;
    font-weight: bold;
  }
  button:hover { background: #388e3c; }
  button:active { background: #1b5e20; }
  button:disabled { background: #555; cursor: default; }
  button.deal-btn { background: #c6a700; color: #1a472a; }
  button.deal-btn:hover { background: #d4b800; }
  
  .info {
    color: #8fb;
    font-size: 0.6em;
    text-align: center;
    margin-top: 4px;
    opacity: 0.7;
  }
  
  .stage-label {
    font-size: 0.8em;
    color: #ffd54f;
    margin-bottom: 2px;
    font-weight: bold;
    min-height: 1em;
  }

  .card-enter { animation: cardIn 0.3s ease-out; }
  @keyframes cardIn {
    from { transform: scale(0.5) rotate(-10deg); opacity: 0; }
    to { transform: scale(1) rotate(0); opacity: 1; }
  }
  .computing { font-size: 0.5em; color: #aaa; text-align: center; margin-bottom: 4px; min-height: 0.8em; }
</style>
</head>
<body>

<h1>üÉè Short Deck (6+) Viewer</h1>
<div class="subtitle">36Êûö„Éá„ÉÉ„Ç≠Ôºà2„Äú5Èô§ÂéªÔºâ/ 9‰∫∫„ÉÜ„Éº„Éñ„É´</div>

<div class="board-area">
  <div class="stage-label" id="stageLabel"></div>
  <div class="board-label">BOARD</div>
  <div class="board-cards" id="board"></div>
</div>

<div class="computing" id="computing"></div>
<div class="players-grid" id="players"></div>

<div class="controls">
  <button class="deal-btn" id="dealBtn" onclick="newHand()">üÇ† DEAL</button>
  <button id="nextBtn" onclick="nextStreet()" disabled>NEXT ‚Üí</button>
  <button id="autoBtn" onclick="toggleAuto()">‚ñ∂ AUTO</button>
</div>

<div class="info">
  Short Deck: RF > SF > Quads > <strong>Flush</strong> > Full House > <strong>Straight</strong> > Trips > 2P > 1P > High<br>
  A6789 = ÊúÄÂ∞è„Çπ„Éà„É¨„Éº„Éà / „Éï„É©„ÉÉ„Ç∑„É• &gt; „Éï„É´„Éè„Ç¶„Çπ
</div>

<script>
const SUITS = ['s','h','d','c'];
const SUIT_DISPLAY = {'s':'‚ô†','h':'‚ô•','d':'‚ô¶','c':'‚ô£'};
const SUIT_COLORS = {'s':'black','c':'black','h':'red','d':'red'};
const RANKS = ['6','7','8','9','T','J','Q','K','A'];
const RANK_VAL = {'6':6,'7':7,'8':8,'9':9,'T':10,'J':11,'Q':12,'K':13,'A':14};
const PLAYER_NAMES = ['P1','P2','P3','P4','P5','P6','P7','P8','P9'];

// Short Deck hand rankings (higher = better)
// RF=9, SF=8, Quads=7, Flush=6, FullHouse=5, Straight=4, Trips=3, TwoPair=2, OnePair=1, HighCard=0
const HAND_NAMES = ['„Éè„Ç§„Ç´„Éº„Éâ','„ÉØ„É≥„Éö„Ç¢','„ÉÑ„Éº„Éö„Ç¢','„Éà„É™„ÉÉ„Éó„Çπ','„Çπ„Éà„É¨„Éº„Éà','„Éï„É´„Éè„Ç¶„Çπ','„Éï„É©„ÉÉ„Ç∑„É•','„ÇØ„ÉØ„ÉÉ„Ç∫','„Çπ„Éà„É¨„Éº„Éà„Éï„É©„ÉÉ„Ç∑„É•','„É≠„Ç§„É§„É´„Éï„É©„ÉÉ„Ç∑„É•'];

let deck, fullDeck, playerHands, boardCards, stage, autoTimer, winners;
let playerEvals = null;
let playerEquities = null;
let playerDraws = null;
let folded = new Array(9).fill(false);

function makeDeck() {
  const d = [];
  for (const s of SUITS) for (const r of RANKS) d.push({ rank: r, suit: s });
  for (let i = d.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}

function cardKey(c) { return c.rank + c.suit; }

function cardHTML(card, extra = '') {
  const color = SUIT_COLORS[card.suit];
  const disp = SUIT_DISPLAY[card.suit];
  return `<div class="card ${color} ${extra} card-enter">
    <span class="rank">${card.rank}</span>
    <span class="suit">${disp}</span>
  </div>`;
}

function renderBoard() {
  const el = document.getElementById('board');
  let html = '';
  for (let i = 0; i < 5; i++) {
    if (i < boardCards.length) {
      html += cardHTML(boardCards[i], 'board-card');
    } else {
      html += '<div class="placeholder"></div>';
    }
  }
  el.innerHTML = html;
}

function renderPlayers() {
  const el = document.getElementById('players');
  let html = '';
  for (let i = 0; i < 9; i++) {
    const isWinner = winners && winners.includes(i);
    const hand = playerHands[i];
    const ev = playerEvals ? playerEvals[i] : null;
    const eq = playerEquities ? playerEquities[i] : null;
    const dr = playerDraws ? playerDraws[i] : [];
    const isFolded = folded[i];
    const cls = isWinner ? 'winner' : (isFolded ? 'folded' : '');
    html += `<div class="player ${cls}" onclick="foldPlayer(${i})">
      <div class="player-name">${isWinner ? 'üèÜ ' : ''}${PLAYER_NAMES[i]}</div>
      <div class="player-hand">`;
    html += cardHTML(hand[0]) + cardHTML(hand[1]);
    html += `</div>`;
    if (!isFolded) {
      html += `<div class="player-info">${ev ? getHandLabel(ev, dr, hand, boardCards) : ''}</div>`;
      if (eq !== null && stage < 4) {
        html += `<div class="player-equity">${eq}%</div>`;
      } else {
        html += `<div class="player-equity"></div>`;
      }
    } else {
      html += `<div class="player-info"></div><div class="player-equity"></div>`;
    }
    html += `</div>`;
  }
  el.innerHTML = html;
}

function updateStageLabel() {
  const labels = ['PREFLOP', 'FLOP', 'TURN', 'RIVER', 'SHOWDOWN'];
  document.getElementById('stageLabel').textContent = labels[stage] || '';
}

// ======= HAND EVALUATION (Short Deck) =======

function getCombinations(arr, k) {
  if (k === 0) return [[]];
  if (arr.length < k) return [];
  const result = [];
  function helper(start, combo) {
    if (combo.length === k) { result.push([...combo]); return; }
    for (let i = start; i < arr.length; i++) {
      combo.push(arr[i]);
      helper(i + 1, combo);
      combo.pop();
    }
  }
  helper(0, []);
  return result;
}

function evaluateHand5(cards) {
  const vals = cards.map(c => RANK_VAL[c.rank]).sort((a, b) => b - a);
  const suits = cards.map(c => c.suit);
  
  const isFlush = suits.every(s => s === suits[0]);
  
  let isStraight = false;
  let straightHigh = 0;
  
  const unique = [...new Set(vals)].sort((a, b) => b - a);
  if (unique.length === 5) {
    if (unique[0] - unique[4] === 4) {
      isStraight = true;
      straightHigh = unique[0];
    }
    // A6789 wheel
    if (!isStraight && unique[0] === 14 && unique[1] === 9 && unique[2] === 8 && unique[3] === 7 && unique[4] === 6) {
      isStraight = true;
      straightHigh = 9;
    }
  }
  
  const counts = {};
  for (const v of vals) counts[v] = (counts[v] || 0) + 1;
  const groups = Object.entries(counts).map(([v, c]) => ({ val: +v, count: c }));
  groups.sort((a, b) => b.count - a.count || b.val - a.val);
  
  const isRoyal = isFlush && isStraight && unique[0] === 14 && unique[4] === 10;
  
  if (isRoyal) return { rank: 9, score: [9, 14] };
  if (isFlush && isStraight) return { rank: 8, score: [8, straightHigh] };
  if (groups[0].count === 4) return { rank: 7, score: [7, groups[0].val, groups[1].val] };
  // Flush > Full House > Straight > Trips
  if (isFlush) return { rank: 6, score: [6, ...vals] };
  if (groups[0].count === 3 && groups[1].count === 2) return { rank: 5, score: [5, groups[0].val, groups[1].val] };
  
  if (isStraight) return { rank: 4, score: [4, straightHigh] };
  
  if (groups[0].count === 3) {
    const kickers = groups.filter(g => g.count === 1).map(g => g.val).sort((a, b) => b - a);
    return { rank: 3, score: [3, groups[0].val, ...kickers] };
  }
  if (groups[0].count === 2 && groups[1].count === 2) {
    const pairs = [groups[0].val, groups[1].val].sort((a, b) => b - a);
    return { rank: 2, score: [2, pairs[0], pairs[1], groups[2].val] };
  }
  if (groups[0].count === 2) {
    const kickers = groups.filter(g => g.count === 1).map(g => g.val).sort((a, b) => b - a);
    return { rank: 1, score: [1, groups[0].val, ...kickers] };
  }
  return { rank: 0, score: [0, ...vals] };
}

function evaluateBest(holeCards, board) {
  const allCards = [...holeCards, ...board];
  if (allCards.length < 5) {
    // Less than 5 cards: evaluate what we can
    if (allCards.length === 2) {
      if (allCards[0].rank === allCards[1].rank) {
        const v = RANK_VAL[allCards[0].rank];
        return { rank: 1, score: [1, v] };
      }
      const vals = allCards.map(c => RANK_VAL[c.rank]).sort((a,b) => b-a);
      return { rank: 0, score: [0, ...vals] };
    }
    if (allCards.length >= 3) {
      const vals = allCards.map(c => RANK_VAL[c.rank]).sort((a,b) => b-a);
      const counts = {};
      for (const v of vals) counts[v] = (counts[v] || 0) + 1;
      const groups = Object.entries(counts).map(([v,c]) => ({val:+v, count:c}));
      groups.sort((a,b) => b.count - a.count || b.val - a.val);
      
      if (groups[0].count === 3) return { rank: 3, score: [3, groups[0].val] };
      if (groups[0].count === 2 && groups.length >= 2 && groups[1].count === 2) {
        const pairs = [groups[0].val, groups[1].val].sort((a,b) => b-a);
        return { rank: 2, score: [2, ...pairs] };
      }
      if (groups[0].count === 2) return { rank: 1, score: [1, groups[0].val] };
      return { rank: 0, score: [0, ...vals] };
    }
  }
  const combos = getCombinations(allCards, 5);
  let best = null;
  for (const combo of combos) {
    const ev = evaluateHand5(combo);
    if (!best || compareScores(ev.score, best.score) > 0) best = ev;
  }
  return best;
}

// ======= DRAW DETECTION =======
function detectDraws(holeCards, board, currentRank) {
  if (board.length === 0 || board.length === 5) return [];
  const allCards = [...holeCards, ...board];
  const draws = [];
  
  // Flush draw: 4 of same suit (only show if current hand < flush=6)
  if (currentRank < 6) {
    const suitCounts = {};
    for (const c of allCards) suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1;
    for (const s in suitCounts) {
      if (suitCounts[s] === 4) draws.push('FD');
    }
  }
  
  // Straight draw (only show if current hand < straight=4)
  if (currentRank < 4) {
    const vals = [...new Set(allCards.map(c => RANK_VAL[c.rank]))].sort((a,b) => a - b);
    const valsWithLowA = vals.includes(14) ? [5, ...vals] : [...vals];
    const uniqueVals = [...new Set(valsWithLowA)].sort((a,b) => a - b);
    
    // Count how many distinct ranks complete ANY straight
    const completingRanks = new Set();
    const straightStarts = [5, 6, 7, 8, 9, 10];
    for (const start of straightStarts) {
      const needed = [start, start+1, start+2, start+3, start+4];
      const missing = needed.filter(n => !uniqueVals.includes(n));
      if (missing.length === 1) {
        // This rank completes a straight
        // Map value 5 back to 14 (Ace)
        completingRanks.add(missing[0] === 5 ? 14 : missing[0]);
      }
    }
    
    if (completingRanks.size >= 2) {
      draws.push('OESD');
    } else if (completingRanks.size === 1) {
      draws.push('GS');
    }
  }
  
  return draws;
}

function getTripsLabel(holeCards, board) {
  if (board.length === 0) return '„Éù„Ç±„ÉÉ„Éà';
  // Find the trips rank
  const allCards = [...holeCards, ...board];
  const counts = {};
  for (const c of allCards) counts[c.rank] = (counts[c.rank] || 0) + 1;
  const tripsRank = Object.keys(counts).find(r => counts[r] >= 3);
  if (!tripsRank) return '„Éà„É™„ÉÉ„Éó„Çπ';
  
  const holeMatch = holeCards.filter(c => c.rank === tripsRank).length;
  if (holeMatch === 2) return '„Çª„ÉÉ„Éà';
  return '„Éà„É™„ÉÉ„Éó„Çπ';
}

function getHandLabel(ev, draws, holeCards, board) {
  let label = HAND_NAMES[ev.rank];
  // Override for trips/set distinction
  if (ev.rank === 3) label = getTripsLabel(holeCards, board);
  if (draws.length > 0) {
    const drawLabels = draws.map(d => {
      if (d === 'FD') return 'F„Éâ„É≠„Éº';
      if (d === 'OESD') return 'OESD';
      if (d === 'GS') return '„Ç¨„ÉÉ„Éà„Ç∑„Éß„ÉÉ„Éà';
      return d;
    });
    label += ' + ' + drawLabels.join(', ');
  }
  return label;
}

function compareScores(a, b) {
  for (let i = 0; i < Math.max(a.length, b.length); i++) {
    const av = a[i] || 0, bv = b[i] || 0;
    if (av > bv) return 1;
    if (av < bv) return -1;
  }
  return 0;
}

function foldPlayer(idx) {
  if (stage >= 4 || folded[idx]) return; // Can't fold at showdown or if already folded
  folded[idx] = true;
  // Check if only 1 player left
  const active = folded.filter(f => !f).length;
  if (active <= 1) {
    // Auto showdown - last player wins
    doShowdown();
    return;
  }
  updateEvals();
  renderPlayers();
  updateEquities();
}

// ======= EQUITY CALCULATION (Monte Carlo) =======

function calcEquities() {
  const usedKeys = new Set();
  for (const h of playerHands) { usedKeys.add(cardKey(h[0])); usedKeys.add(cardKey(h[1])); }
  for (const c of boardCards) usedKeys.add(cardKey(c));
  
  const remaining = [];
  for (const s of SUITS) for (const r of RANKS) {
    const k = r + s;
    if (!usedKeys.has(k)) remaining.push({ rank: r, suit: s });
  }
  
  const boardNeeded = 5 - boardCards.length;
  if (boardNeeded === 0) {
    const evals = playerHands.map(h => evaluateBest(h, boardCards));
    let bestScore = null;
    let winnerIdxs = [];
    for (let i = 0; i < 9; i++) {
      if (folded[i]) continue;
      const cmp = bestScore ? compareScores(evals[i].score, bestScore) : 1;
      if (cmp > 0) { bestScore = evals[i].score; winnerIdxs = [i]; }
      else if (cmp === 0) winnerIdxs.push(i);
    }
    const eq = new Array(9).fill(0);
    for (const w of winnerIdxs) eq[w] = 100;
    if (winnerIdxs.length > 1) {
      const split = Math.round(100 / winnerIdxs.length);
      for (const w of winnerIdxs) eq[w] = split;
    }
    return eq;
  }
  
  const SIMS = 800;
  const wins = new Array(9).fill(0);
  
  for (let sim = 0; sim < SIMS; sim++) {
    for (let i = remaining.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [remaining[i], remaining[j]] = [remaining[j], remaining[i]];
    }
    const simBoard = [...boardCards, ...remaining.slice(0, boardNeeded)];
    
    let bestScore = null;
    let winnerIdxs = [];
    for (let i = 0; i < 9; i++) {
      if (folded[i]) continue;
      const ev = evaluateBest(playerHands[i], simBoard);
      const cmp = bestScore ? compareScores(ev.score, bestScore) : 1;
      if (cmp > 0) { bestScore = ev.score; winnerIdxs = [i]; }
      else if (cmp === 0) winnerIdxs.push(i);
    }
    const share = 1 / winnerIdxs.length;
    for (const w of winnerIdxs) wins[w] += share;
  }
  
  return wins.map(w => Math.round(w / SIMS * 100));
}

// ======= GAME FLOW =======

function updateEvals() {
  playerEvals = playerHands.map(h => evaluateBest(h, boardCards));
  playerDraws = playerHands.map((h, i) => detectDraws(h, boardCards, playerEvals[i].rank));
}

function updateEquities() {
  document.getElementById('computing').textContent = 'Ë®àÁÆó‰∏≠...';
  // Use setTimeout to let UI update
  setTimeout(() => {
    playerEquities = calcEquities();
    document.getElementById('computing').textContent = '';
    renderPlayers();
  }, 10);
}

function newHand() {
  stopAuto();
  deck = makeDeck();
  playerHands = [];
  boardCards = [];
  stage = 0;
  winners = null;
  playerEvals = null;
  playerEquities = null;
  playerDraws = null;
  folded = new Array(9).fill(false);

  for (let i = 0; i < 9; i++) {
    playerHands.push([deck.pop(), deck.pop()]);
  }

  updateEvals();
  renderPlayers();
  renderBoard();
  updateStageLabel();
  document.getElementById('nextBtn').disabled = false;
  updateEquities();
}

function doShowdown() {
  stage = 4;
  playerEvals = playerHands.map(h => evaluateBest(h, boardCards));
  playerDraws = playerHands.map(() => []);
  let bestScore = null;
  let winnerIdxs = [];
  for (let i = 0; i < 9; i++) {
    if (folded[i]) continue;
    const cmp = bestScore ? compareScores(playerEvals[i].score, bestScore) : 1;
    if (cmp > 0) { bestScore = playerEvals[i].score; winnerIdxs = [i]; }
    else if (cmp === 0) winnerIdxs.push(i);
  }
  winners = winnerIdxs;
  playerEquities = null;
  renderBoard();
  renderPlayers();
  updateStageLabel();
  document.getElementById('nextBtn').disabled = true;
  document.getElementById('computing').textContent = '';
}

function nextStreet() {
  if (stage >= 4) return;
  stage++;

  if (stage === 1) {
    deck.pop(); boardCards.push(deck.pop(), deck.pop(), deck.pop());
  } else if (stage === 2) {
    deck.pop(); boardCards.push(deck.pop());
  } else if (stage === 3) {
    // River ‚Üí auto showdown
    deck.pop(); boardCards.push(deck.pop());
    renderBoard();
    doShowdown();
    return;
  }

  updateEvals();
  renderBoard();
  renderPlayers();
  updateStageLabel();
  updateEquities();
}

let autoRunning = false;
function toggleAuto() {
  if (autoRunning) stopAuto(); else startAuto();
}

function startAuto() {
  autoRunning = true;
  document.getElementById('autoBtn').textContent = '‚è∏ STOP';
  document.getElementById('autoBtn').style.background = '#c62828';
  autoStep();
}

function stopAuto() {
  autoRunning = false;
  clearTimeout(autoTimer);
  document.getElementById('autoBtn').textContent = '‚ñ∂ AUTO';
  document.getElementById('autoBtn').style.background = '#2e7d32';
}

function autoStep() {
  if (!autoRunning) return;
  if (stage >= 4 || playerHands.length === 0) {
    newHand();
    autoTimer = setTimeout(autoStep, 2500);
  } else {
    nextStreet();
    const delay = stage === 1 ? 2500 : stage >= 4 ? 3500 : 2000;
    autoTimer = setTimeout(autoStep, delay);
  }
}

newHand();
</script>
</body>
</html>
